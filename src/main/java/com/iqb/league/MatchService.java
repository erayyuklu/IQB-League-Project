package com.iqb.league;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

public class MatchService {
    private Connection connection;

    public MatchService(Connection connection) {
        this.connection = connection;
    }


    // Method to simulate a match and determine the winner
    public void simulateMatch(Match match) {
        // Base chances
        double homeBaseChance = 0.50;
        double awayBaseChance = 0.50;

        // Home advantage effect
        double homeAdvantage = 0.10; // %10
        double homeChanceWithAdvantage = homeBaseChance + homeAdvantage;

        // OverallScore effect
        double scoreDifference = match.getHomeTeam().getOverallScore() - match.getAwayTeam().getOverallScore();
        double scaledEffect;

        if (scoreDifference < -100) {
            scaledEffect = -0.25; // Difference is less than -100
        } else if (scoreDifference > 100) {
            scaledEffect = +0.25;  // Difference is more than +100
        } else {
            scaledEffect = scoreDifference * 25 / 10000; // Difference is between -100 and +100
        }

        // Update the home and away chances
        double homeChance = Math.min(homeChanceWithAdvantage + scaledEffect, 1.0);
        double awayChance = 1.0 - homeChance;

        // Draw chance
        double drawChance = 0.10;

        // Normalize the possibilities
        double totalChance = homeChance + awayChance;
        homeChance = (homeChance / totalChance) * (1.0 - drawChance);
        awayChance = (awayChance / totalChance) * (1.0 - drawChance);

        // Determine the winner
        double random = Math.random();
        if (random <= drawChance) {
            match.setHomeScore((byte) (Math.random() * 3)); // Scores between 0-2
            match.setAwayScore(match.getHomeScore()); // Same score
            System.out.println(match.getHomeTeam().getName() + " (home) - " + match.getAwayTeam().getName() + " (away) The match ended in a draw with a score of " + match.getHomeScore() + "-" + match.getAwayScore() + ".");
        } else if (random <= drawChance + homeChance) {
            match.setHomeScore((byte) (Math.random() * 3 + 2)); // Scores between 2-4
            match.setAwayScore((byte) (Math.random() * 2)); // Scores between 0-1
            System.out.println(match.getHomeTeam().getName() + " (home) won the match against " + match.getAwayTeam().getName() + " (away) with a score of " + match.getHomeScore() + "-" + match.getAwayScore() + "!");
        } else {
            match.setHomeScore((byte) (Math.random() * 2)); // Scores between 0-1
            match.setAwayScore((byte) (Math.random() * 3 + 2)); // Scores between 2-4
            System.out.println(match.getAwayTeam().getName() + " (away) won the match against " + match.getHomeTeam().getName() + " (home) with a score of " + match.getAwayScore() + "-" + match.getHomeScore() + "!");
        }

        // After simulating, update the overall scores
        updateOverallScores(match);
    }
    // Method to update the overall scores of the teams after the match
    public void updateOverallScores(Match match) {
        if (match.getHomeScore() > match.getAwayScore()) {
            match.getHomeTeam().setOverallScore(match.getHomeTeam().getOverallScore() + 3);
            match.getAwayTeam().setOverallScore(match.getAwayTeam().getOverallScore() - 1);
        } else if (match.getAwayScore() > match.getHomeScore()) {
            match.getAwayTeam().setOverallScore(match.getAwayTeam().getOverallScore() + 3);
            match.getHomeTeam().setOverallScore(match.getHomeTeam().getOverallScore() - 1);
        } else {
            match.getHomeTeam().setOverallScore(match.getHomeTeam().getOverallScore() + 1);
            match.getAwayTeam().setOverallScore(match.getAwayTeam().getOverallScore() + 1);
        }
    }

    // Method to process MatchDTO before the match simulation
    public void dto_process_before_match(Match match, boolean isFirst, byte weekNum, MatchDTO matchDTO) {
        // Fill in details before the match
        matchDTO.setMatchId(0); // Assuming ID is auto-generated by the DB
        matchDTO.setMatch_first_or_second(isFirst ? 'f' : 's');
        matchDTO.setMatch_week_num(weekNum);

        // Set home team details
        matchDTO.setHomeTeamId(match.getHomeTeam().getId());
        matchDTO.setHomeOverallBefore(match.getHomeTeam().getOverallScore());

        // Set away team details
        matchDTO.setAwayTeamId(match.getAwayTeam().getId());
        matchDTO.setAwayOverallBefore(match.getAwayTeam().getOverallScore());
    }

    // Method to process MatchDTO after the match simulation
    public void dto_process_after_match(Match match, MatchDTO matchDTO) {
        // Set the overall scores after the match
        matchDTO.setHomeOverallAfter(match.getHomeTeam().getOverallScore());
        matchDTO.setAwayOverallAfter(match.getAwayTeam().getOverallScore());

        // Set match scores
        matchDTO.setHomeScore(match.getHomeScore());
        matchDTO.setAwayScore(match.getAwayScore());
    }

    // New method to process all matches in the league
    public void do_matches(League league) {
        // Process first half matches
        List<List<Match>> firstHalfFixtures = league.getFirstHalfFixtures();
        List<MatchDTO> firstHalfDTOs =process_half_matches(firstHalfFixtures, true);
        saveMatchDTOsToDatabase(firstHalfDTOs);

        // Process second half matches
        List<List<Match>> secondHalfFixtures = league.getSecondHalfFixtures();
        List<MatchDTO> secondHalfDTOs = process_half_matches(secondHalfFixtures, false);
        saveMatchDTOsToDatabase(secondHalfDTOs);
    }

    // Helper method to process matches for each half
    private List<MatchDTO> process_half_matches(List<List<Match>> halfFixtures, boolean isFirst) {
        List<MatchDTO> matchDTOs = new ArrayList<>();
        for (byte weekNum = 1; weekNum <= halfFixtures.size(); weekNum++) {
            List<Match> weeklyMatches = halfFixtures.get(weekNum - 1); // Get matches for this week

            for (Match match : weeklyMatches) {
                MatchDTO matchDTO = new MatchDTO(); // Create a new DTO for each match

                // Process before match
                dto_process_before_match(match, isFirst, weekNum, matchDTO);

                // Simulate the match
                simulateMatch(match);  // Call MatchService's simulateMatch

                // Process after match
                dto_process_after_match(match, matchDTO);

                matchDTOs.add(matchDTO);
            }
        }

        return matchDTOs;
    }


    public void saveMatchDTOsToDatabase(List<MatchDTO> matchDTOs) {
        String insertSQL = "INSERT INTO matches (" +
                "match_first_or_second, " +
                "match_week_num, " +
                "match_home_team_id, " +
                "match_away_team_id, " +
                "match_home_overall_before, " +
                "match_away_overall_before, " +
                "match_home_overall_after, " +
                "match_away_overall_after, " +
                "match_home_score, " +
                "match_away_score" +
                ") VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        try (PreparedStatement pstmt = connection.prepareStatement(insertSQL)) {

            for (MatchDTO dto : matchDTOs) {
                pstmt.setString(1, String.valueOf(dto.getMatch_first_or_second()));
                pstmt.setShort(2, dto.getMatch_week_num());
                pstmt.setInt(3, dto.getHomeTeamId());
                pstmt.setInt(4, dto.getAwayTeamId());
                pstmt.setInt(5, dto.getHomeOverallBefore());
                pstmt.setInt(6, dto.getAwayOverallBefore());
                pstmt.setInt(7, dto.getHomeOverallAfter());
                pstmt.setInt(8, dto.getAwayOverallAfter());
                pstmt.setByte(9, dto.getHomeScore());
                pstmt.setByte(10, dto.getAwayScore());

                pstmt.addBatch();
            }

            // Execute the batch
            pstmt.executeBatch();

        } catch (SQLException e) {
            e.printStackTrace();
            // Handle SQL exceptions
        }
    }
}
